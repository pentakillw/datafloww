
// UTILITIES FOR CODE GENERATION & EXPORT

// --- SQL GENERATOR ---
export const generateSQL = (data, columns, fileName) => {
    if (!data || !data.length) return "-- Sin datos para generar SQL";
    const tableName = fileName ? fileName.split('.')[0].replace(/[^a-zA-Z0-9_]/g, '_') : 'nocodepy_table';
    
    let sql = `-- --------------------------------------------------------\n`;
    sql += `-- EXPORTADO POR NOCODEPY\n`;
    sql += `-- Tabla: ${tableName}\n`;
    sql += `-- Generado: ${new Date().toISOString()}\n`;
    sql += `-- --------------------------------------------------------\n\n`;
    
    // Create Table
    sql += `CREATE TABLE IF NOT EXISTS ${tableName} (\n`;
    sql += columns.map(col => `    "${col}" TEXT`).join(',\n');
    sql += `\n);\n\n`;
    
    // Insert Data in Batches of 500 to avoid query size limits
    const BATCH_SIZE = 500;
    const chunks = [];
    
    for (let i = 0; i < data.length; i += BATCH_SIZE) {
        const batch = data.slice(i, i + BATCH_SIZE);
        let insert = `INSERT INTO ${tableName} (${columns.map(c => `"${c}"`).join(', ')}) VALUES\n`;
        
        const rows = batch.map(row => { 
            const values = columns.map(col => {
                let val = row[col];
                if (val === null || val === undefined) return 'NULL';
                // Escape single quotes
                return `'${String(val).replace(/'/g, "''")}'`; 
            }).join(', ');
            return `(${values})`;
        }).join(',\n');
        
        chunks.push(insert + rows + ';\n');
    }
    
    return sql + chunks.join('\n');
};

// --- PYTHON TKINTER GENERATOR (ADVANCED) ---
export const generatePythonGUI = (pipelines) => {
    // pipelines structure: { 'filename_pattern': { actions: [...], description: '...' } }
    // If pipelines is just actions array (legacy), convert it
    let pipelinesDict = {};
    if (Array.isArray(pipelines)) {
        pipelinesDict['single_file_mode'] = {
            pattern: '*', // Match all in single mode
            actions: pipelines,
            description: 'TransformaciÃ³n Actual'
        };
    } else {
        pipelinesDict = pipelines || {};
    }

    // Serialize pipelines to inject into Python code
    const pipelinesJson = JSON.stringify(pipelinesDict);

    return `"""
# -----------------------------------------------------------------------------
# GENERATED BY NOCODEPY - AUTOMATION ENGINE v2.0
# -----------------------------------------------------------------------------
# 
# 1. Este cÃ³digo fuente es generado automÃ¡ticamente por NoCodePY.
# 2. Licencia de uso personal e interno.
# 3. Requiere: pip install pandas numpy openpyxl
# 
# -----------------------------------------------------------------------------
"""
import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext, ttk
import pandas as pd
import numpy as np
import os
import threading
import json
import glob
import time
from datetime import datetime

# --- CONFIGURACIÃ“N VISUAL ---
COLOR_BG = "#1e1e1e"
COLOR_PANEL = "#252526" 
COLOR_SIDEBAR = "#2d2d30"
COLOR_ACCENT = "#029CA3" 
COLOR_TEXT = "#FDFDFD"
COLOR_TEXT_DIM = "#AAAAAA"
FONT_MAIN = ("Segoe UI", 10)
FONT_HEADER = ("Segoe UI", 14, "bold")
FONT_MONO = ("Consolas", 9)

# --- PIPELINES DE TRANSFORMACIÃ“N ---
PIPELINES = ${pipelinesJson}

class AutomationEngine:
    """Motor de procesamiento de datos independiente de la GUI"""
    
    @staticmethod
    def apply_transformations(df, actions, logger_func):
        if not actions:
            logger_func("âš  No hay transformaciones. Se exporta original.", "warning")
            return df
            
        for idx, action in enumerate(actions):
            desc = action.get('description', f"AcciÃ³n {action['type']}")
            logger_func(f"  â””â”€ [PASO {idx+1}] {desc}...", "info")
            
            try:
                atype = action['type']
                
                # --- LIMPIEZA BÃSICA ---
                if atype == 'SMART_CLEAN':
                    df = df.applymap(lambda x: x.strip() if isinstance(x, str) else x)
                    df.dropna(how='all', inplace=True)
                    df.drop_duplicates(inplace=True)

                # --- ESTRUCTURA ---
                elif atype == 'REORDER_COLS':
                    cols = action['newOrder']
                    existing = [c for c in cols if c in df.columns]
                    df = df[existing]
                elif atype == 'DROP_COLUMN':
                    if action['col'] in df.columns: df.drop(columns=[action['col']], inplace=True)
                elif atype == 'RENAME':
                    df.rename(columns={action['col']: action['newVal']}, inplace=True)
                elif atype == 'ADD_INDEX':
                    df.insert(0, 'ID', range(1, 1 + len(df)))
                
                # --- TEXTO ---
                elif atype == 'TRIM':
                    if action['col'] in df.columns: df[action['col']] = df[action['col']].astype(str).str.strip()
                elif atype == 'CASE_CHANGE':
                    if action['col'] in df.columns:
                        if action['mode'] == 'upper': df[action['col']] = df[action['col']].astype(str).str.upper()
                        elif action['mode'] == 'lower': df[action['col']] = df[action['col']].astype(str).str.lower()
                        elif action['mode'] == 'title': df[action['col']] = df[action['col']].astype(str).str.title()
                
                # --- FILTROS ---
                elif atype == 'FILTER':
                    col = action['col']
                    val = action['val']
                    if col in df.columns:
                        if action['condition'] == 'equals': df = df[df[col].astype(str) == str(val)]
                        elif action['condition'] == 'contains': df = df[df[col].astype(str).str.contains(str(val), na=False, case=False)]
                        elif action['condition'] == '>': df = df[pd.to_numeric(df[col], errors='coerce') > float(val)]
                        elif action['condition'] == '<': df = df[pd.to_numeric(df[col], errors='coerce') < float(val)]
                
                # --- TIPOS Y NULOS ---
                elif atype == 'FILL_NULLS':
                    if action['col'] in df.columns: df[action['col']].fillna(action['val'], inplace=True)
                elif atype == 'CHANGE_TYPE':
                    if action['col'] in df.columns:
                        if action['to'] == 'numeric': df[action['col']] = pd.to_numeric(df[action['col']], errors='coerce')
                        elif action['to'] == 'date': df[action['col']] = pd.to_datetime(df[action['col']], errors='coerce')
                        elif action['to'] == 'string': df[action['col']] = df[action['col']].astype(str)

                # --- LÃ“GICA DE NEGOCIO ---
                elif atype == 'CALC_MATH':
                    df[action['target']] = pd.to_numeric(df[action['col1']], errors='coerce')  # Simplificado, requiere operador
                
                # (Se pueden aÃ±adir mÃ¡s casos aquÃ­ siguiendo el patrÃ³n)
                
            except Exception as e:
                logger_func(f"    âŒ Error en paso {idx+1}: {str(e)}", "error")
                # No detenemos el flujo completo, pero marcamos el error
        
        return df

class ModernUI(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("NoCodePY | Automation Hub")
        self.geometry("900x650")
        self.configure(bg=COLOR_BG)
        
        # Estilos
        self.style = ttk.Style()
        self.style.theme_use('clam')
        self.style.configure("TFrame", background=COLOR_BG)
        self.style.configure("Sidebar.TFrame", background=COLOR_SIDEBAR)
        self.style.configure("Card.TFrame", background=COLOR_PANEL, relief="flat")
        
        self.current_mode = "single" # single | batch
        self.files_to_process = []
        
        self.setup_ui()
        
    def setup_ui(self):
        # --- HEADER ---
        header = tk.Frame(self, bg=COLOR_PANEL, height=60)
        header.pack(side="top", fill="x")
        tk.Label(header, text="âš¡ NoCodePY", font=("Segoe UI", 16, "bold"), bg=COLOR_PANEL, fg=COLOR_ACCENT).pack(side="left", padx=20)
        tk.Label(header, text="v2.0 Pro", font=("Segoe UI", 10), bg=COLOR_PANEL, fg=COLOR_TEXT_DIM).pack(side="left", pady=15)
        
        # --- SIDEBAR ---
        sidebar = tk.Frame(self, bg=COLOR_SIDEBAR, width=200)
        sidebar.pack(side="left", fill="y")
        
        self.btn_single = self.create_nav_btn(sidebar, "ðŸ“„ Archivo Ãšnico", lambda: self.switch_mode("single"))
        self.btn_batch = self.create_nav_btn(sidebar, "ðŸ“‚ Proyecto Batch", lambda: self.switch_mode("batch"))
        self.btn_logs = self.create_nav_btn(sidebar, "ðŸ“ Logs Sistema", lambda: self.switch_mode("logs"))
        
        tk.Label(sidebar, text="PIPELINES ACTIVOS:", bg=COLOR_SIDEBAR, fg=COLOR_ACCENT, font=("Segoe UI", 8, "bold")).pack(side="bottom", anchor="w", padx=20, pady=(0,5))
        for key in PIPELINES:
             tk.Label(sidebar, text=f"â€¢ {key}", bg=COLOR_SIDEBAR, fg=COLOR_TEXT_DIM, font=("Segoe UI", 8)).pack(side="bottom", anchor="w", padx=20, pady=2)
        tk.Label(sidebar, text="", bg=COLOR_SIDEBAR).pack(side="bottom", pady=10)

        # --- CONTENT AREA ---
        self.content = tk.Frame(self, bg=COLOR_BG)
        self.content.pack(side="right", fill="both", expand=True, padx=20, pady=20)
        
        # Initialize with Single Mode
        self.switch_mode("single")

    def create_nav_btn(self, parent, text, cmd):
        btn = tk.Button(parent, text=text, command=cmd, bg=COLOR_SIDEBAR, fg=COLOR_TEXT, font=("Segoe UI", 11), bd=0, activebackground=COLOR_ACCENT, activeforeground="white", cursor="hand2", anchor="w", padx=20, pady=10)
        btn.pack(fill="x", pady=2)
        return btn

    def switch_mode(self, mode):
        self.current_mode = mode
        # Reset buttons styles
        for btn in [self.btn_single, self.btn_batch, self.btn_logs]:
            btn.configure(bg=COLOR_SIDEBAR, fg=COLOR_TEXT)
        
        if mode == "single": self.btn_single.configure(bg=COLOR_ACCENT)
        elif mode == "batch": self.btn_batch.configure(bg=COLOR_ACCENT)
        else: self.btn_logs.configure(bg=COLOR_ACCENT)
        
        # Clear content
        for widget in self.content.winfo_children(): widget.destroy()
        
        if mode == "single": self.render_single_mode()
        elif mode == "batch": self.render_batch_mode()
        elif mode == "logs": self.render_logs_mode()

    # --- VISTAS ---
    def render_single_mode(self):
        tk.Label(self.content, text="Procesamiento de Archivo Individual", font=("Segoe UI", 18, "bold"), bg=COLOR_BG, fg=COLOR_TEXT).pack(anchor="w", pady=(0, 20))
        
        card = tk.Frame(self.content, bg=COLOR_PANEL, padx=20, pady=20)
        card.pack(fill="x", pady=10)
        
        tk.Label(card, text="Selecciona un archivo (.csv / .xlsx) para aplicar las transformaciones.", bg=COLOR_PANEL, fg=COLOR_TEXT_DIM).pack(anchor="w", pady=(0, 10))
        
        row = tk.Frame(card, bg=COLOR_PANEL)
        row.pack(fill="x")
        self.entry_file = tk.Entry(row, bg="#333", fg="white", font=FONT_MAIN, relief="flat")
        self.entry_file.pack(side="left", fill="x", expand=True, ipady=5, padx=(0, 10))
        tk.Button(row, text="Examinar...", command=self.browse_file, bg="#444", fg="white", relief="flat", padx=15).pack(side="right")
        
        self.btn_run = tk.Button(self.content, text="â–¶ EJECUTAR AHORA", command=self.run_single, bg=COLOR_ACCENT, fg="white", font=("Segoe UI", 12, "bold"), relief="flat", cursor="hand2", pady=10)
        self.btn_run.pack(fill="x", pady=20)
        
        self.log_widget = scrolledtext.ScrolledText(self.content, height=10, bg="#111", fg="#0f0", font=FONT_MONO, relief="flat", state="disabled")
        self.log_widget.pack(fill="both", expand=True, pady=20)

    def render_batch_mode(self):
        tk.Label(self.content, text="Procesamiento por Lotes (Batch)", font=("Segoe UI", 18, "bold"), bg=COLOR_BG, fg=COLOR_TEXT).pack(anchor="w", pady=(0, 5))
        tk.Label(self.content, text="Procesa mÃºltiples archivos automÃ¡ticamente segÃºn patrones.", bg=COLOR_BG, fg=COLOR_TEXT_DIM).pack(anchor="w", pady=(0, 20))

        # --- OPCIONES DE PROCESAMIENTO ---
        opts_frame = tk.Frame(self.content, bg=COLOR_BG)
        opts_frame.pack(fill="x", pady=10)
        
        self.batch_mode_var = tk.StringVar(value="auto") # auto | merge
        
        # OpciÃ³n 1: Procesar Individualmente (Auto-detectar)
        rb1 = tk.Radiobutton(opts_frame, text="Procesar individualmente (Auto-detectar reglas)", variable=self.batch_mode_var, value="auto", bg=COLOR_BG, fg=COLOR_TEXT, selectcolor=COLOR_BG, activebackground=COLOR_BG, activeforeground=COLOR_ACCENT, font=("Segoe UI", 10))
        rb1.pack(anchor="w")
        
        # OpciÃ³n 2: Unificar y Procesar (Merge)
        rb2 = tk.Radiobutton(opts_frame, text="Unificar archivos (Merge) y procesar juntos", variable=self.batch_mode_var, value="merge", bg=COLOR_BG, fg=COLOR_TEXT, selectcolor=COLOR_BG, activebackground=COLOR_BG, activeforeground=COLOR_ACCENT, font=("Segoe UI", 10))
        rb2.pack(anchor="w")

        card = tk.Frame(self.content, bg=COLOR_PANEL, padx=20, pady=20)
        card.pack(fill="x", pady=10)
        
        tk.Label(card, text="Carpeta de Origen:", bg=COLOR_PANEL, fg=COLOR_TEXT).pack(anchor="w")
        row = tk.Frame(card, bg=COLOR_PANEL)
        row.pack(fill="x", pady=5)
        self.entry_folder = tk.Entry(row, bg="#333", fg="white", font=FONT_MAIN, relief="flat")
        self.entry_folder.pack(side="left", fill="x", expand=True, ipady=5, padx=(0, 10))
        tk.Button(row, text="Seleccionar Carpeta", command=self.browse_folder, bg="#444", fg="white", relief="flat").pack(side="right")

        # --- LISTA DE ARCHIVOS ESPERADOS (PROYECTO) ---
        tk.Label(self.content, text="Archivos del Proyecto (Detectados vs Esperados):", bg=COLOR_BG, fg=COLOR_TEXT_DIM).pack(anchor="w", pady=(10, 5))
        
        # Frame para el Treeview con scrollbar
        tree_frame = tk.Frame(self.content, bg=COLOR_BG)
        tree_frame.pack(fill="x", pady=5)
        
        columns = ("archivo", "estado", "reglas")
        self.tree_files = ttk.Treeview(tree_frame, columns=columns, show="headings", height=5)
        self.tree_files.heading("archivo", text="Archivo")
        self.tree_files.heading("estado", text="Estado")
        self.tree_files.heading("reglas", text="Reglas")
        
        self.tree_files.column("archivo", width=250)
        self.tree_files.column("estado", width=100)
        self.tree_files.column("reglas", width=100)
        
        self.tree_files.pack(side="left", fill="x", expand=True)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(tree_frame, orient="vertical", command=self.tree_files.yview)
        scrollbar.pack(side="right", fill="y")
        self.tree_files.configure(yscrollcommand=scrollbar.set)
        
        # Inicializar lista
        self.refresh_file_list()

        self.btn_run_batch = tk.Button(self.content, text="â–¶ INICIAR PROCESAMIENTO BATCH", command=self.run_batch, bg=COLOR_ACCENT, fg="white", font=("Segoe UI", 12, "bold"), relief="flat", cursor="hand2", pady=10)
        self.btn_run_batch.pack(fill="x", pady=20)
        
        self.log_widget = scrolledtext.ScrolledText(self.content, height=15, bg="#111", fg="#0f0", font=FONT_MONO, relief="flat", state="disabled")
        self.log_widget.pack(fill="both", expand=True, pady=20)

    def render_logs_mode(self):
        tk.Label(self.content, text="Historial de Logs", font=("Segoe UI", 18, "bold"), bg=COLOR_BG, fg=COLOR_TEXT).pack(anchor="w", pady=(0, 20))
        self.log_widget = scrolledtext.ScrolledText(self.content, bg="#111", fg="#ccc", font=FONT_MONO, relief="flat")
        self.log_widget.pack(fill="both", expand=True)
        self.log_widget.insert(tk.END, "Esperando operaciones...")

    # --- LOGICA ---
    def browse_file(self):
        fn = filedialog.askopenfilename(filetypes=[("Data Files", "*.csv *.xlsx")])
        if fn:
            self.entry_file.delete(0, tk.END); self.entry_file.insert(0, fn)
            
    def browse_folder(self):
        fn = filedialog.askdirectory()
        if fn:
            self.entry_folder.delete(0, tk.END); self.entry_folder.insert(0, fn)
            self.refresh_file_list(fn)

    def refresh_file_list(self, folder=None):
        # Limpiar treeview
        for i in self.tree_files.get_children():
            self.tree_files.delete(i)
            
        # Si no hay pipelines (modo single file simple sin proyecto), no mostrar nada o mostrar genÃ©rico
        if not PIPELINES: return

        for filename, pipe in PIPELINES.items():
            # Omitir claves genÃ©ricas si las hubiera
            if filename == 'single_file_mode': continue
            
            status = "Pendiente"
            tag = "pending"
            
            if folder:
                # Verificar si existe en la carpeta
                # Intentar match exacto o case-insensitive
                found = False
                try:
                    files_in_folder = os.listdir(folder)
                    for f in files_in_folder:
                        if f.lower() == filename.lower():
                            found = True
                            break
                except:
                    pass
                
                if found:
                    status = "âœ… Encontrado"
                    tag = "found"
                else:
                    status = "âŒ No encontrado"
                    tag = "missing"
            
            num_rules = len(pipe.get('actions', []))
            self.tree_files.insert("", "end", values=(filename, status, f"{num_rules} pasos"), tags=(tag,))
        
        self.tree_files.tag_configure('found', foreground='green')
        self.tree_files.tag_configure('missing', foreground='red')
        self.tree_files.tag_configure('pending', foreground='gray')

    def log(self, msg, level="info"):
        timestamp = datetime.now().strftime("%H:%M:%S")
        icon = "â„¹"
        if level == "error": icon = "âŒ"
        if level == "warning": icon = "âš "
        if level == "success": icon = "âœ…"
        
        formatted = f"[{timestamp}] {icon} {msg}\\n"
        
        if hasattr(self, 'log_widget'):
            self.log_widget.config(state="normal")
            self.log_widget.insert(tk.END, formatted)
            self.log_widget.see(tk.END)
            self.log_widget.config(state="disabled")
        
        self.update_idletasks()

    def run_single(self):
        fp = self.entry_file.get()
        if not fp or not os.path.exists(fp):
            messagebox.showerror("Error", "Archivo no vÃ¡lido")
            return
        
        threading.Thread(target=self._process_task, args=([fp], "single")).start()

    def run_batch(self):
        folder = self.entry_folder.get()
        if not folder or not os.path.exists(folder):
            messagebox.showerror("Error", "Carpeta no vÃ¡lida")
            return
            
        # Encontrar archivos que coincidan con los patrones de las pipelines
        files = []
        
        exts = ['*.csv', '*.xlsx']
        for ext in exts:
            files.extend(glob.glob(os.path.join(folder, ext)))
            
        if not files:
            self.log("No se encontraron archivos CSV/Excel en la carpeta.", "warning")
            return
            
        threading.Thread(target=self._process_task, args=(files, "batch")).start()

    def _process_task(self, files, mode):
        batch_mode = self.batch_mode_var.get() if hasattr(self, 'batch_mode_var') else "auto"
        self.log(f"Iniciando proceso {mode.upper()} ({batch_mode}) con {len(files)} archivos...", "info")
        
        # --- MODO MERGE (UNIFICADO) ---
        if mode == 'batch' and batch_mode == 'merge':
            try:
                self.log("Unificando archivos...", "info")
                dfs = []
                for fp in files:
                    try:
                        if fp.endswith('.csv'): df_temp = pd.read_csv(fp)
                        else: df_temp = pd.read_excel(fp)
                        dfs.append(df_temp)
                    except Exception as e:
                        self.log(f"  âŒ Error leyendo {os.path.basename(fp)}: {e}", "error")
                
                if not dfs:
                    self.log("No se pudieron cargar archivos para unificar.", "error")
                    return

                full_df = pd.concat(dfs, ignore_index=True)
                self.log(f"Archivos unificados. Total filas: {len(full_df)}", "success")
                
                # Aplicar la primera pipeline disponible (asumimos que al unificar siguen la misma estructura)
                key = next(iter(PIPELINES))
                pipeline = PIPELINES[key]
                
                self.log(f"Aplicando reglas de: {key}", "info")
                full_df = AutomationEngine.apply_transformations(full_df, pipeline['actions'], self.log)
                
                out_dir = os.path.join(os.path.dirname(files[0]), "output")
                os.makedirs(out_dir, exist_ok=True)
                out_path = os.path.join(out_dir, f"merged_output_{int(time.time())}.csv")
                
                full_df.to_csv(out_path, index=False)
                self.log(f"âœ… Archivo unificado guardado: {os.path.basename(out_path)}", "success")
                
            except Exception as e:
                self.log(f"âŒ Error en proceso Merge: {str(e)}", "error")
            
            self.log("ðŸ Proceso Merge finalizado.", "success")
            messagebox.showinfo("Terminado", "El procesamiento unificado ha finalizado.")
            return

        # --- MODO INDIVIDUAL (AUTO) ---
        for fp in files:
            fname = os.path.basename(fp)
            self.log(f"Procesando: {fname}...", "info")
            
            try:
                # 1. Cargar
                if fp.endswith('.csv'): df = pd.read_csv(fp)
                else: df = pd.read_excel(fp)
                
                # 2. Determinar Pipeline
                # En modo single_file, usamos la 'single_file_mode' pipeline (o la primera disponible)
                pipeline = None
                if mode == 'single':
                    # Usar la primera disponible o la default
                    key = next(iter(PIPELINES))
                    pipeline = PIPELINES[key]
                else:
                    # BATCH AUTO: Intentar coincidir nombre
                    if len(PIPELINES) == 1:
                        key = next(iter(PIPELINES))
                        pipeline = PIPELINES[key]
                    else:
                        # LÃ³gica de coincidencia simple
                        for key, pipe in PIPELINES.items():
                            if pipe.get('pattern') and pipe['pattern'] in fname: 
                                pipeline = pipe
                                break
                            # Fallback: si el nombre del archivo contiene el nombre de la pipeline
                            if key.lower() in fname.lower():
                                pipeline = pipe
                                break
                
                if not pipeline:
                    self.log(f"  âš  No se encontrÃ³ pipeline coincidente para {fname}. Saltando.", "warning")
                    continue
                
                # 3. Transformar
                df = AutomationEngine.apply_transformations(df, pipeline['actions'], self.log)
                
                # 4. Guardar
                out_name = f"processed_{fname}"
                if mode == 'batch':
                    out_dir = os.path.join(os.path.dirname(fp), "output")
                    os.makedirs(out_dir, exist_ok=True)
                    out_path = os.path.join(out_dir, out_name)
                else:
                    out_path = os.path.join(os.path.dirname(fp), out_name)
                    
                df.to_csv(out_path, index=False)
                self.log(f"  âœ… Guardado en: {os.path.basename(out_path)}", "success")
                
            except Exception as e:
                self.log(f"  âŒ Error crÃ­tico en archivo: {str(e)}", "error")
                
        self.log("ðŸ Proceso finalizado.", "success")
        messagebox.showinfo("Terminado", "El procesamiento ha finalizado.")

if __name__ == "__main__":
    app = ModernUI()
    app.mainloop()
`;
};

// --- POWER QUERY (M) GENERATOR ---
export const generateMCode = (fileName, columns, actions) => {
    let steps = `let\n    Source = Csv.Document(File.Contents("C:\\Data\\${fileName || 'file.csv'}"),[Delimiter=",", Columns=${columns.length}, Encoding=65001, QuoteStyle=QuoteStyle.None]),\n    #"Promoted Headers" = Table.PromoteHeaders(Source, [PromoteAllScalars=true])`;
    let lastStep = `#"Promoted Headers"`;

    actions.forEach((action, idx) => {
        const stepName = `Step${idx + 1}`;
        let mFunc = "";
        
        switch (action.type) {
            case 'RENAME': mFunc = `Table.RenameColumns(${lastStep}, {{"${action.col}", "${action.newVal}"}})`; break;
            case 'DROP_COLUMN': mFunc = `Table.RemoveColumns(${lastStep}, {"${action.col}"})`; break;
            case 'FILTER': 
                if (action.condition === 'equals') mFunc = `Table.SelectRows(${lastStep}, each ([${action.col}] = "${action.val}"))`;
                else if (action.condition === 'contains') mFunc = `Table.SelectRows(${lastStep}, each Text.Contains([${action.col}], "${action.val}"))`;
                else mFunc = `Table.SelectRows(${lastStep}, each [${action.col}] ${action.condition} ${action.val})`;
                break;
            case 'CHANGE_TYPE': {
                const typeMap = { 'numeric': 'Int64.Type', 'string': 'type text', 'date': 'type date' };
                mFunc = `Table.TransformColumnTypes(${lastStep}, {{"${action.col}", ${typeMap[action.to] || 'type any'}}})`;
                break;
            }
            case 'TRIM': mFunc = `Table.TransformColumns(${lastStep}, {{"${action.col}", Text.Trim, type text}})`; break;
            case 'CASE_CHANGE':
                if (action.mode === 'upper') mFunc = `Table.TransformColumns(${lastStep}, {{"${action.col}", Text.Upper, type text}})`;
                else if (action.mode === 'lower') mFunc = `Table.TransformColumns(${lastStep}, {{"${action.col}", Text.Lower, type text}})`;
                else mFunc = `Table.TransformColumns(${lastStep}, {{"${action.col}", Text.Proper, type text}})`;
                break;
            case 'ADD_INDEX': mFunc = `Table.AddIndexColumn(${lastStep}, "Index", 1, 1, Int64.Type)`; break;
            case 'REMOVE_DUPLICATES': mFunc = `Table.Distinct(${lastStep})`; break;
            case 'FILL_DOWN': mFunc = `Table.FillDown(${lastStep}, {"${action.col}"})`; break;
            default: mFunc = `${lastStep} // AcciÃ³n no soportada en M: ${action.type}`;
        }
        
        steps += `,\n    #"${stepName}" = ${mFunc}`;
        lastStep = `#"${stepName}"`;
    });

    return steps + `\nin\n    ${lastStep}`;
};

// --- R SCRIPT GENERATOR ---
export const generateRCode = (fileName, actions) => {
    let r = `# R Script generado por NoCodePY\nlibrary(readr)\nlibrary(dplyr)\n\n`;
    r += `df <- read_csv("${fileName || 'data.csv'}")\n\n`;
    
    actions.forEach(action => {
        r += `# ${action.description}\n`;
        switch (action.type) {
            case 'RENAME': r += `df <- df %>% rename(${action.newVal} = ${action.col})\n`; break;
            case 'DROP_COLUMN': r += `df <- df %>% select(-${action.col})\n`; break;
            case 'FILTER': 
                if (action.condition === 'equals') r += `df <- df %>% filter(${action.col} == "${action.val}")\n`;
                else if (action.condition === 'contains') r += `df <- df %>% filter(grepl("${action.val}", ${action.col}))\n`;
                else r += `df <- df %>% filter(${action.col} ${action.condition} ${action.val})\n`;
                break;
            case 'TRIM': r += `df$${action.col} <- trimws(df$${action.col})\n`; break;
            case 'CASE_CHANGE':
                if (action.mode === 'upper') r += `df$${action.col} <- toupper(df$${action.col})\n`;
                else if (action.mode === 'lower') r += `df$${action.col} <- tolower(df$${action.col})\n`;
                break;
            case 'ADD_INDEX': r += `df$ID <- 1:nrow(df)\n`; break;
            case 'REMOVE_DUPLICATES': r += `df <- unique(df)\n`; break;
            default: r += `# AcciÃ³n pendiente: ${action.type}\n`;
        }
    });
    return r + `\nwrite_csv(df, "output_processed.csv")`;
};
